stop("Algo ha fallado y no existen correlaciones")
}
# aspecto del fichero
kable(head(corr_df, n= 10L), caption = "Primeras 10 parejas del fichero de correlaciones")
# presentación de las correlaciones
plot(corr_df)
write.table(corr_df,
file = "BestCorrelations.tsv",
sep = "\t",
row.names = FALSE,
col.names = TRUE,
quote = FALSE)
HAYGENES <- length(MY_IDS) > 0
# define a customised matplot()
MyMatPlot <- function(m,
mainTitle = "Gene profiles") {
# Leave room for legend outside the plot
par(mar = c(5, 4, 4, 8), xpd = TRUE)
# plot de la matriz
matplot(t(m),  # transpose to put columns as x an gene expression as y
ylab = "Expression level",
main = mainTitle,
type = "b", pch = 0:25,
lty = 1:5, lwd = 2, col = c(1:6),
las = 2,
xaxt = "n") # remove x labels
# define new x labels
axis(1,  # below
at = 1:ncol(m),
labels = colnames(m),
las = 2,
cex.axis = 0.7)
# legend outside the plot
legend("topright",
inset = c(-0.25, 0), # legend outside the plot
legend = rownames(m),
lty = 1:5, lwd = 2, col = c(1:6),
bty= "o",
pch = 0:25,
cex = 0.7)
}
# los datos. Si solo hay un ID, se vuelve vector
myIDs_expr <- matriz_filt[rownames(matriz_filt) %in% MY_IDS, ]
# representación de los datos
MyMatPlot(myIDs_expr,
mainTitle = "Gene profiles in log2")
# Con ggplot hay que trasponer la matriz
xxx <- data.frame(t(myIDs_expr))
# el índce no pueden ser caracteres. Por eso rownames(xxx) no vale
# new_x <- rep(1:4, each=3)
new_x <- 1:12
samples_names <- rownames(xxx)
xxx <- cbind(new_x, xxx)
head(xxx) # para ver la columna adicional para representar el eje X
# reordenamos la tabla para que ggplot la represente bien
xxx2 <- melt(xxx,  id.vars = 'new_x', variable.name = 'gene')
head(xxx2)
ggp <- ggplot(xxx2, aes(new_x, value)) +
# colour lines per gene
geom_line(aes(colour = gene)) +
# resize points with the same colour than lines
geom_point(size = 1.25, aes(colour = gene)) +
# change x continuous labels for sample names
scale_x_continuous(name = "Samples", breaks = 1:length(samples_names), labels = samples_names) +
# change legend and Y title
scale_y_continuous(name = "Log-expression level") +
# add the title
ggtitle("Interactive profiles of selected genes") +
# simplify the plot lines and colours
theme_linedraw() +
# change orientation and size of sample names, title, background, legend, axis...
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
legend.position = "none",
panel.grid = element_line(color = "lightgray", linewidth = 0.5),
plot.title = element_text(lineheight = 0.8, face = "bold", size = 12, colour = "darkgreen"))
# print the interactive plot created with ggplot()
ggplotly(ggp)
# método clásico con línea de tendencia e intervalo
ggplot(xxx2, aes(x=new_x, y=value)) +
# poner línea en roja y = 0
geom_hline(yintercept=0, linetype=4, color="red") +
geom_line(aes(colour=gene, group=gene), linewidth=0.5, alpha=0.3) +
# indicar las columnas de valor+SD y valor-SD para barras de error
# geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2)) +
# Trend line with confidence interval
geom_smooth(method = 'loess', linewidth = 2, se = TRUE, color = "orange") +
# another theme for lines and colours
theme_light()
# para no depender de los nombres de las columnas, con valor medio y fondo típico de ggplot
ggcolnam <- colnames(xxx2)
ggplot(xxx2, aes(x=xxx2[, 1], y=xxx2[, 3])) +
# poner línea roja en y = 0
geom_hline(yintercept=0, linetype=4, color="red") +
geom_line(aes(colour=xxx2[, 2], group=xxx2[, 2]), linewidth=0.5, alpha=0.3) +
# indicar las columnas de valor+SD y valor-SD para barras de error
# geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2)) +
# mean line in blue
stat_summary(aes(y=xxx2[, 3]), fun=mean, geom='line', linewidth=2, color='blue') +
scale_x_continuous(name = ggcolnam[1], breaks = 1:length(samples_names), labels = samples_names) +
# change orientation and size of sample names
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
# change legend and Y title
scale_y_continuous(name = ggcolnam[3]) +
labs(colour = ggcolnam[2])
# IDs de MY_IDS que sí están en matriz_filt
myIDs_exrp_names <- rownames(matriz_filt)[rownames(matriz_filt) %in% MY_IDS]
HAYGENES <- length(myIDs_exrp_names) > 0
if (HAYGENES) message("Genes semilla con los que buscar correlaciones: ", toString(myIDs_exrp_names))
myCorr_df <- data.frame(
Item1 = numeric(),
Item2 = numeric(),
r = numeric(),
abs.r = numeric(),
P = numeric()
)
myCorr_df[1,] <- c(0, 0, 0, 0, 0) # la eliminamos luego
# cuántas vueltas hay que darle a la matriz myIDs_exrp_names
id_cicles <- length(myIDs_exrp_names)
# cuántas vueltas hay que darle a la matriz matriz_filt
row_cicles <- nrow(matriz_filt) # número de filas
# correlacionar los genes de una matriz con los de la otra
if (id_cicles == 1) {                 # solo hay una fila en myIDs_exrp_names
myIDs_expr <- as.vector(myIDs_expr) # convertir la fila en un vector
for (i in 1:row_cicles) {           # empezamos a recorrer matriz_filt
# correlaciona fila de x=myIDs_exrp_names con cada fila de y=matriz_filt
r_p <- cor.test(myIDs_expr, matriz_filt[i,], method=CORR_METHOD)
# añade resultados al dataframe myCorr_df: miGen, GenMatriz, r, |r| y P
myCorr_df <- rbind(myCorr_df, c(myIDs_exrp_names, rownames(matriz_filt)[i], r_p$estimate, abs(r_p$estimate), r_p$p.value))
}
} else {                              # podemos recorrer myIDs_exrp_names
for (j in 1:id_cicles) {
for (i in 1:row_cicles) {
r_p <- cor.test(myIDs_expr[j,], matriz_filt[i,], method=CORR_METHOD)
myCorr_df <- rbind(myCorr_df, c(myIDs_exrp_names[j], rownames(matriz_filt)[i], r_p$estimate, abs(r_p$estimate), r_p$p.value))
}
# eliminamos la primera columna porque la habíamos llenado de ceros
myCorr_df <- myCorr_df[-1, ]
# vemos el comienzo de las correlaciones que se han hecho
kable(head(myCorr_df), caption = "Primeras correlaciones calculadas")
# filtramos por correlacion y significatividad
tmp = myCorr_df[myCorr_df$abs.r >= R_MIN & myCorr_df$P <= P_MIN,]
# la ordenamos
myCorr_ord <- tmp[order(tmp$abs.r, decreasing = TRUE), ]
rm(tmp) # eliminamos variables innecesarias
message(paste0("Número de correlaciones que pasan: ", nrow(myCorr_ord)))
kable(head(myCorr_ord), caption = "Correlaciones más altas con los genes de interés")
# Guardamos las parejas de correlaciones
write.table(myCorr_ord,
file = "Correlacion_con_genes_de_interes.tsv",
sep = "\t",
col.names = NA,
quote = FALSE)
aNet <- graph.data.frame(myCorr_ord[, 1:2], directed = FALSE)
plot.igraph(aNet,
main = "Correlation-based network",
vertex.label = NA,
vertex.size = 8)
rglplot(aNet)
aNet <- graph.data.frame(myCorr_ord[, 1:2], directed = FALSE)
plot.igraph(aNet,
main = "Correlation-based network",
vertex.label = myIDs_exrp_names,
vertex.size = 8)
aNet <- graph.data.frame(myCorr_ord[, 1:2], directed = FALSE)
plot.igraph(aNet,
main = "Correlation-based network",
# vertex.label = NA,
mark.groups = myIDs_exrp_names,
vertex.size = 8)
aNet <- graph.data.frame(myCorr_ord[, 1:2], directed = FALSE)
plot.igraph(aNet,
main = "Correlation-based network",
vertex.label = NA,
mark.groups = myIDs_exrp_names,
vertex.size = 8)
rglplot(aNet)
tkplot(aNet)
aNet <- graph.data.frame(myCorr_ord[, 1:2], directed = FALSE)
plot.igraph(aNet,
main = "Correlation-based network",
mark.groups = myIDs_exrp_names,  # marca los genes de interés
vertex.label = NA,
vertex.size = 8)
ggp_tmp <- visNetwork::visIgraph(aNet) %>%
visNetwork::visNodes(size = 10)
print(ggp_tmp)
visNetwork::visIgraph(aNet)
aNet <- graph.data.frame(myCorr_ord[, 1:2], directed = FALSE)
plot.igraph(aNet,
main = "Correlation-based network",
mark.groups = myIDs_exrp_names,  # marca los genes de interés
vertex.label = NA,
vertex.size = 8)
visNetwork::visIgraph(aNet)
library("knitr")
opts_chunk$set(echo = TRUE)
T00 <- proc.time() # initial time
# selecciona un fichero .tsv
INTERACTIVE_READ <- TRUE; FILE_PATH <- file.choose() # copia esta línea en el terminal
# usa el path que hayas copiado que apunta a un fichero tsv
dataInFile <- read.delim(FILE_PATH, sep="\t")
message("Tabla leíada de disco; contiene ", dim(dataInFile), "filas y columnas")
# usa el path que hayas copiado que apunta a un fichero tsv
dataInFile <- read.delim(FILE_PATH, sep="\t")
message("Tabla leíada de disco; contiene ", toString(dim(dataInFile)), " filas y columnas")
file.choose()
INTERACTIVE_READ <- FALSE # para decidir si se hará la parte interactive
tmp_PATH1 <- ""
tmp_PATH2 <- ""
tmp_path <- "/Users/claros/Documents/MisScriptsR/RSeqFlow/README.md"
length(tmp_path)
nchar(tmp_path)
tmp_PATH2 <- ""
nchar(tmp_PATH2)
file.choose()
?autoplot
??autoplot
?ggfortify::autoplot
library(ggfortify)
?autoplot
#| label: setup
#| include: TRUE
rm(list=ls())                      # limpiar la RAM al empezar la ejecución
gc()                               # garbage collection; returns free RAM to the operating system
T00 <- proc.time()                 # initial time
my_computer <- Sys.info()[c(4, 1, 5, 7)]
library(gganimate)  # es nuevo
library(Rtsne)
library(patchwork)
data(Diabetes, package="heplots")  # hay que cargar el paquete heplots
str(Diabetes)
levels(Diabetes$group)
kable(Diabetes[1:5, ])
#| label: setup
#| include: TRUE
rm(list=ls())                      # limpiar la RAM al empezar la ejecución
gc()                               # garbage collection; returns free RAM to the operating system
T00 <- proc.time()                 # initial time
my_computer <- Sys.info()[c(4, 1, 5, 7)]
library("knitr")
if(!require(ggplot2, quietly = TRUE)){
install.packages("ggplot2", dependencies = TRUE)
library("ggplot2")
}
# Representaciones de datos de clustering y PCA
if(!require(factoextra, quietly = TRUE)){
install.packages("factoextra", dependencies = TRUE)
library("factoextra")
}
# para que las etiquetas de los gráficos no se solapen
if(!require(ggrepel, quietly = TRUE)){
install.packages("ggrepel", dependencies = TRUE)
library("ggrepel")
}
# para que autoplot() entienda los resultados de las k-medias
if(!require(ggfortify, quietly = TRUE)){
install.packages("ggfortify", dependencies = TRUE)
library("ggfortify")
}
kable(head(mtcars), caption = "Original mtcars dataset")             # original data
mtcarsub <- mtcars[, c(1, 3:7)]                                      # Remove discrete variables
kable(head(mtcarsub), caption = "Only numeric variables of mtcars")
pca <- prcomp(mtcarsub,                   # Perform PCA
scale=TRUE)
summary(pca)
ggp0 <- fviz_pca_biplot(pca,              # Visualize PCA via biplot
col.var = "black",
col.ind = "steelblue",
alpha.var = 0.6,
repel = TRUE,
labelsize = 2) +
labs(x = "PC1 (69.8%)",
y = "PC2 (19.1%)")
ggp0                                      # Print biplot
#| fig-width: 6
pca_scores <- data.frame(pca$x[, 1:2])    # Extract PC1 and PC2
ggp1 <- fviz_nbclust(pca_scores,          # Determine number of clusters
FUNcluster = kmeans,
method = "wss")
ggp1                                      # Print within sum of squares plot
set.seed(123)                             # Set seed for randomization
kmeans_clust <- kmeans(pca_scores,        # Perform k-means clustering
centers = 4)
kmeans_clust                              # Summary of clustering results
#| label: PCA-results  # si uso fig-PCA-results, no funciona igual
#| fig-show: hold
#| fig-cap: "Result of PCA + k-means."
#| fig-subcap:
#|   - "Using the basic plot() function"
#|   - "Using fviz_pca_ind()"
#| layout-ncol: 2
#| column: body
plot(pca_scores,
col = kmeans_clust$cluster)
ggp2 <- fviz_pca_ind(pca,                 # Visualize clusters
habillage = kmeans_clust$cluster,
repel = TRUE,
addEllipses = TRUE,
ellipse.type = "convex",
labelsize = 2) +
guides(color = guide_legend(override.aes = list(label = ""))) +
labs(x = "PC1 (69.8%)", y = "PC2 (19.1%)")
ggp2                                      # Print cluster plot
ggp3 <- fviz_pca_biplot(pca,              # Visualize clusters in biplot
col.var = "black",
alpha.var = 0.6,
label = "all",
habillage = kmeans_clust$cluster,
repel = TRUE,
addEllipses = TRUE,
ellipse.type = "convex",
labelsize = 2) +
guides(color = guide_legend(override.aes = list(label = ""))) +
labs(x ="PC1 (69.8%)", y = "PC2 (19.1%)")
ggp3                                      # Print combined plot
#| label: fig-kmeans-alone
#| fig-show: hold
#| fig-cap: "K-means clustering without previous PCA."
#| layout-ncol: 2
#| column: body
mtc_scaled <- scale(mtcarsub)         # scale data
set.seed(123)                         # Set seed for randomization
kmeans_clust <- kmeans(mtc_scaled,    # Perform k-means clustering on scaled data
centers = 4,
nstart = 25)    # try 25 different random assignments to select the best one
ggp4 <- fviz_cluster(kmeans_clust,
data = mtc_scaled,
labelsize = 8,
geom = "point",
ggtheme = theme_minimal(),        # tema mínimo (de ggplot)
habillage = kmeans_clust$cluster,
repel = TRUE,                     # Avoid label overplotting (slow)
ellipse.type = "convex",          # or 'norm'
main = "Four direct clusters using k-means")
ggp4
autoplot(kmeans_clust,
data = mtcarsub,
frame = TRUE,                     # rodea cada cluster para mostrar mejor la clasificación
shape = kmeans_clust$cluster,
loadings = TRUE,                  # las flechas reflejan la contribudión de cada parámetro
loadings.colour = 'orange1',      # color de las flechas
loadings.label = TRUE,            # etiqueta de la flecha
loadings.label.colour='orange3',  # color de la etiquetq
loadings.label.size = 3,          # tamaño de la etiqueta
main = "K-means using autoplot")
library(gganimate)  # es nuevo
library(Rtsne)
library(patchwork)
data(Diabetes, package="heplots")  # hay que cargar el paquete heplots
str(Diabetes)
levels(Diabetes$group)
kable(Diabetes[1:5, ])
#| label: PCA1
diab.pca <- prcomp(Diabetes[, 1:5], scale = TRUE, rank.=2)
df1 <- data.frame(diab.pca$x, group = Diabetes$group)
colnames(df1) <- c("Dim1", "Dim2", "group")
df1 <- cbind(df1, method="PCA")
p1 <- ggplot(df1, aes(x=Dim1, y=Dim2, color=group, shape=group)) +
geom_point(size = 3) +
stat_ellipse(level = 0.68, linewidth=1.1) +
geom_hline(yintercept = 0) +
geom_vline(xintercept = 0) +
labs(x = "Dimension 1",
y = "Dimension 2") +
ggtitle("PCA") +
theme_bw(base_size = 16) +
theme(legend.position = "right")
p1
summary(diab.pca)
diab.pca
diab.pca <- prcomp(Diabetes[, 1:5], scale = TRUE)
summary(diab.pca)
#| label: tsne
set.seed(123)
diab.tsne <- Rtsne(Diabetes[, 1:5], scale = TRUE)
df2 <- data.frame(diab.tsne$Y, group = Diabetes$group)
colnames(df2) <- c("Dim1", "Dim2", "group")
df2 <- cbind(df2, method="tSNE")
p2 <- ggplot(df2, aes(x=Dim1, y=Dim2, color = group, shape=group)) +
geom_point(size = 3) +
stat_ellipse(level = 0.68, linewidth=1.1) +
geom_hline(yintercept = 0) +
geom_vline(xintercept = 0) +
labs(x = "Dimension 1",
y = "Dimension 2") +
ggtitle("tSNE") +
theme_bw(base_size = 16) +
theme(legend.position = "right")
p2
diab.tsne
summary(diab.tsne)
table(rpois(100, 5))
a <- rep(c(NA, 1/0:3), 10)
a
table(a)
table(a > 1)
table(a > 2)
table(a < 0)
names(table(a < 0))
names(table(a))
nn <- names(table(a))
nn
str(nn)
nn <- names(table(a <0))
lengh(nn)
length(nn)
expected_names <- c(TRUE, FALSE)
nn %in% expected_names
xpected_names %in% nn
expected_names %in% nn
!expected_names %in% nn
Avoid_0_counts <- function(aTable) {
column_names <- names(aTable)
if (length(column_names) == 1) {
expected_names <- c(TRUE, FALSE)
aTable[[(!expected_names %in% nn)]] <- 0
}
table(a < 0)
Avoid_0_counts(table(a < 0))
expected_names(!expected_names %in% nn)
expected_names[!expected_names %in% nn]
Avoid_0_counts <- function(aTable) {
column_names <- names(aTable)
if (length(column_names) == 1) {
expected_names <- c(TRUE, FALSE)
lack_name <- expected_names[!expected_names %in% nn]
aTable[[lack_name]] <- 0
}
Avoid_0_counts(table(a < 0))
Avoid_0_counts <- function(aTable) {
column_names <- names(aTable)
if (length(column_names) == 1) {
expected_names <- c(TRUE, FALSE)
lack_name <- expected_names[!expected_names %in% nn]
aTable[[lack_name]] <- 0
}
return(aTable)
}
j <- Avoid_0_counts(table(a < 0))
j
Avoid_0_counts <- function(aTable) {
column_names <- names(aTable)
if (length(column_names) == 1) {
expected_names <- c(TRUE, FALSE)
lack_name <- expected_names[!(expected_names %in% nn)]
aTable[[lack_name]] <- 0
}
return(aTable)
}
j <- Avoid_0_counts(table(a < 0))
j
table(a < 0)
table(a > 0)
table(a > 1)
j <- Avoid_0_counts(table(a > 1))
j
expected_names <- c(TRUE, FALSE)
Avoid_0_counts <- function(aTable) {
column_names <- names(aTable)
if (length(column_names) == 1) {
expected_names <- c(TRUE, FALSE)
lack_name <- expected_names[!(expected_names %in% column_names)]
aTable[[lack_name]] <- 0
}
return(aTable)
}
j <- Avoid_0_counts(table(a > 1))
j
j <- Avoid_0_counts(table(a < 0))
j
column_names<- names(table(a < 0))
expected_names[!(expected_names %in% column_names)]
expected_names <- c("TRUE", "FALSE")
expected_names[!(expected_names %in% column_names)]
Avoid_0_counts <- function(aTable) {
column_names <- names(aTable)
if (length(column_names) == 1) {
expected_names <- c("TRUE", "FALSE")
lack_name <- expected_names[!(expected_names %in% column_names)]
aTable[[lack_name]] <- 0
}
return(aTable)
}
j <- Avoid_0_counts(table(a < 0))
j
j <- Avoid_0_counts(table(a > 1))
j
table(a > 1)
warning("aaaa", "bbb")
warning("aaaa", "\nbbb")
table(rpois(100, 5))
length(table(rpois(100, 5)))
a <- rep(c(NA, 1/0:3), 10)
table(a)
length(table(a))
b <- rep(c(NA, 1/0:4), 4)
table(b)
b <- rep(c(NA, (1/1:5 - 1), 6)
table(b)
b <- rep(c(NA, (1/1:5) - 1, 6)
table(b)
b <- rep(c(NA, 0:5 - 1, 6)
table(b)
b <- rep(c(NA, 0:5, 6)
table(b)
b <- rep(c(NA, 0:5), 6)
table(b)
length(b)
length(table(b))
b <- rep(c(NA, 0:5), 23)
table(b)
length(table(b))
